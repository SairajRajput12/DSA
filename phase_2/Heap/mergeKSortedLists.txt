/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    ListNode* solve(ListNode* head,ListNode* comparingWith){
        if(!head){
            return comparingWith; 
        }

        if(!comparingWith){
            return head; 
        }
        ListNode* ans = (head -> val <= comparingWith -> val) ? head : comparingWith; 
        ans -> next = (head -> val <= comparingWith -> val) ? solve(head->next,comparingWith) : solve(head,comparingWith->next); 
        return ans; 
    }
    
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
    // approach 1: using minHeap 
        // priority_queue<int,vector<int>,greater<int>> minHeap;  
        // for(auto it: lists){
        //     ListNode* head = it; 
        //     while(head != NULL){
        //         minHeap.push(head -> val); 
        //         head = head -> next; 
        //     }
        // }

        // ListNode* head = new ListNode(-1); 
        // ListNode* curr = head; 

        // while(!minHeap.empty()){
        //     ListNode* newNode = new ListNode(minHeap.top()); 
        //     minHeap.pop(); 
        //     curr -> next= newNode; 
        //     curr = curr -> next; 
        // }

        // return head -> next;       

    // approach 2: using recursion 
        if(lists.size() == 0) return NULL; 
        ListNode* head = lists[0]; 
        for(int i = 1; i < lists.size(); i ++){
            head = solve(head,lists[i]); 
        }
        return head; 
    }
};

